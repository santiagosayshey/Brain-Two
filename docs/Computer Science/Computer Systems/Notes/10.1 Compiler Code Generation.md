> *When I am working on a problem, I never think about beauty. But when I have finished, if the solution is not beautiful, I know it is wrong.* - R. Buckminster Fuller (1895–1993)
## Code Generation
- The goal is to convert high level language understood by humans, into low level code understood by computers

### Compiling Variables
- All primitive types are 16 bit, so each variable is 1 *word* long
- Static variables should exist only once during the entirety of the program's life
- Field variables should exist for each object and only during that object's life cycle
- Subroutine variables should exist for each time the routine is called and then freed after it ends
	- All of these are handled with the VM memory segments - `static, local, argument, this, that`
- Managed using a symbol table

#### Symbol Table
- When the compiler encounters a variable in a high level statement, it needs to know what memory segment it should belong to and what it represents

```
let y = foo(x)

- static, field, local?
- int, boolean, char, object?
```

- These properties can easily be managed using a **symbol table**
- When a variable is declared in the source code, the compiler allocates the needed VM memory segment and records this mapping in the symbol table
	- Whenever a variable is encountered, it's properties are retrieved from this table or if it doesn't exist yet, is added to it
- These variables can exist in multiple scopes and in which they can possess different properties
	- Static and field variables are scoped to the class in which they are declared
	- Local and arg variables are scoped to the subroutine in which they are declared
	- This is achieved using a symbol table for each scope

![](docs/Images/Pasted%20image%2020231010055227.png)

- Scopes are nested, with inner scopes hiding outer ones
	- Variables are searched outwards and if not found, are added to the symbol table in the current scope
- Jack only has two scopes, the subroutine level and the class level, and therefore, only two symbol tables

#### Variable Declarations
1. **Compiler Start for Class Declaration**:
   - Create class-level symbol table.
   - Create subroutine-level symbol table.

1. **On Parsing `static` or `field` Variable**:
   - Add to class-level table.
   - Record: variable name, type, kind (`static` or `field`), and index within kind.
   
3. **On Starting Subroutine Compilation**:
   - Reset subroutine-level table.
   - If subroutine is a method:
	 - Add row `<this, className, arg, 0>` to subroutine-level table.

1. **On Parsing `local` or `argument` Variable**:
   - Add to subroutine-level table.
   - Record: variable name, type, kind (`var` or `arg`), and index within kind.
   
5. **Indexing**:
   - Start index for each kind (`var` or `arg`) at 0.
   - Increment by 1 for each new variable of that kind added.

#### Variables in Statements
1. **Variable in a Statement**:
   - Compiler first checks subroutine-level symbol table for the variable.
   - If not found, checks class-level symbol table.
   
2. **Variable Found**:
   - Compiler completes translation of the statement.

### Compiling Expressions
- Goal is to convert infix notation (high level) to postfix notation (VM commands)

![](Pasted%20image%2020231010061407.png)

- Achieved using a simple algorithm that parses an expression from left to right
	- Can call itself recursively to handle larger simple expressions

![](Pasted%20image%2020231010061525.png)

- Full definition:

![](Pasted%20image%2020231010061731.png)

### Compiling Strings
- **Jack’s String Handling**:
	- When a string constant appears in code:
		- Compiler generates code to call `String` constructor (creates new `String` object).
		- Initializes object with characters using `appendChar` for each character.
	- Can be inefficient and lead to memory leaks.

- **Example**:
	- Statement: `Output.printString("Loading … please wait")`.
	- Creates a persistent `String` object in memory, even if just displaying a message.
   
-  **Comparison with Modern Languages**:
	- Java, C#, and Python have garbage collection to reclaim memory from unused objects.
	- Modern languages employ optimizations and specialized string classes for efficiency.

### Compiling Statements
- **Jack Statements**:
   - Includes: `let`, `do`, `return`, `if`, `while`.

#### **Compiling `return` Statements**:
   - Call `compileExpression` to evaluate and push expression value to the stack.
   - Generate VM command `return`.

#### **Compiling `let` Statements**:
   - Handle form: `let varName = expression`.
   - Process:
     - Remember `varName`.
     - Call `compileExpression` to push expression value to stack.
     - Generate VM command like `pop varName` (mapped from symbol table, e.g., `local 3`, `static 1`).
   - Array handling of `let` statements discussed later in the chapter.

#### **Compiling `do` Statements**:
   - Handle form: `do className.functionName(exp1, exp2, … , expn)`.
   - Purpose: Call subroutine for effect, disregard return value.
   - Recommendation:
     - Compile as if the syntax is `do expression`.
     - Call `compileExpression`.
     - Remove topmost stack element using command like `pop temp 0`.
   - Compilation for other `do` statement forms discussed later (e.g., `do varName.methodName(...)`, `do methodName(...)`).

#### **Compiling `if` and `while` Statements**:
   - High-level languages have various control flow statements (like `if`, `while`, `for`, `switch`).
   - Low-level languages (assembly, VM) use primitives like conditional `goto` and unconditional `goto`.
   - Challenge: Map high-level control flow to `goto` primitives.
   
- **Compiler Logic for `if` Statements**:
   - Upon detecting `if` keyword, the compiler expects: `if (expression) {statements} else {statements}`.
   - Start with `compileExpression` to compute and push expression's value.
   - Use VM command `not` to negate the expression's value.
   - Generate a label (e.g., `L1`) and follow with VM command `if-goto L1`.
   - Call `compileStatements` to process the sequence of statements (e.g., `let`, `do`, `return`, `if`, `while`).
   
- **Handling Multiple Control Flows**:
   - Programs have multiple `if` and `while` instances.
   - Compiler generates globally unique labels, using a running counter for distinction.
   
- **Nested Control Flows**:
   - Control statements can be nested (e.g., `if` inside `while` inside another `while`).
   - Handled by the recursive nature of `compileStatements`.

![](Pasted%20image%2020231010063102.png)
