## Hashing
- A hash function transforms its input in the following way:
	- The data can be of any size but the hash value is of a fixed size
	- This means that the range of hash values may be (and often is) smaller than the range of values we hash
	- Hash values may not be unique
	- The same data will always generate the same hash value

```
Imagine you have a big box of crayons, and each crayon has a unique, fancy color name like "Sunset Orange" or "Deep Ocean Blue." Now, let's say you want a system to quickly find a crayon without having to read all those long names every time.

So, you decide to label each crayon with a simple number instead. This way, "Sunset Orange" might become "3", and "Deep Ocean Blue" might become "7". 

You do this using a special machine: you put a crayon into it, and it gives you a number. This machine is like our hash function.

Now, here are some things about this crayon-numbering system:

1. No matter how long the crayon's name is, the machine always gives you a small number (fixed size).
2. Sometimes, two different crayons might get the same number because there are so many crayons and only a few numbers to give. This is like when hash values are not unique.
3. Every time you put the same crayon (like "Sunset Orange") into the machine, it will always give you the same number ("3").
```

### Suitability
- Hashed based indexes are best for equality selections.
- They cannot do range searches.

```
A **hashed based index** has a "narrow" search range because it's optimized for pinpointing an exact piece of data. It's like asking, "Where is the book titled 'Moby Dick'?" and getting a direct location.

On the other hand, it's not designed for a "wide" search range where you might ask, "Can you show me all books written by authors whose last name starts with an 'H'?" For such broader, range-based queries, other types of indexes or search methods are more suitable.
```

![[Pasted image 20230821132528.png]]

## Static Hashing
- Build `n` buckets and use the modulus operation to group the range of the hash values to buckets containing data entries
- Collisions over time can lead to many overflow buckets - degrading performance

![[Pasted image 20230821132636.png]]
### Static Hashing: The Post Office Analogy

Imagine a small post office with exactly `n` post boxes where people receive their mail.

1. **Building `n` Buckets**:
   - Think of each post box as a "bucket." The post office has a fixed number (`n`) of these buckets (or post boxes). So, maybe there are 10 post boxes numbered from 0 to 9.

2. **Using the Modulus Operation**:
   - To decide which post box a letter should go into, the post office looks at the last digit of the house number on the letter. If it's house number 123, the last digit is 3, so the letter goes into post box #3. 
   - This is like using the modulus operation! Taking a number (like a house number) and doing "mod 10" gives us a result between 0 and 9, which corresponds to one of our 10 post boxes. 

3. **Collisions**:
   - Now, imagine that there are a LOT of houses with numbers ending in 3. Over time, post box #3 gets really full, while some other post boxes might be almost empty. 
   - In our analogy, this is a "collision". In hashing, when two different pieces of data produce the same hash value (like two house numbers ending in 3), they both want to go into the same bucket, causing a "collision."

4. **Overflow Buckets**:
   - Since post box #3 is full, the post office brings in an extra, temporary box for the excess mail. This is an "overflow bucket." But if even more mail comes for houses with numbers ending in 3, we might need another overflow bucket, and then another.
   - The problem is, every time a letter arrives for a house number ending in 3, the mail carrier has to check the main post box, then the first overflow bucket, then the second, and so on. This can slow down the mail delivery process!

5. **Degrading Performance**:
   - As more overflow buckets are added, the efficiency of our system decreases. Instead of quickly placing mail in the right box, the mail carrier spends more time handling overflows. This is the "degrading performance" part. 

### Considerations
- Buckets can fill - expensive to double number and copy
- IF we don't expand the number of buckets, we risk large overflow chains
- Searching is effective, but maintenence is difficult
- Conceptually simple
- If the index isn't changing then this works very well