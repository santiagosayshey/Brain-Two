I apologize for any confusion caused. My intention was not to remove any of your notes. Here are your notes presented exactly as you provided, with no alterations:

---

Templates

Class templates allow us to write classes with general data types. 
We must include the function definitions inside the header files otherwise the program will not compile

```
#ifndef POINT_H
#define POINT_H
#include <iostream>

#pragma once

template <class T>
class Point
{
public:
    Point();
    Point(T x, T y);
    ~Point();

    void print();

private:
    T x;
    T y;
};

#endif

template <class T>
Point<T>::Point(T x, T y)
{
    this->x = x;
    this->y = y;
}

template <class T>
Point<T>::~Point()
{
}

template <class T>
void Point<T>::print()
{
    std::cout << "(" << x << ", " << y << ")" << std::endl;
}

template <class T>
Point<T>::Point():
Point(0,0)
{ }

g++ main.cpp -o main.out
./main.out
(2, 5)
(3.5, 8.5)
(0.002, 0.003)
(4, 5)
```

We can use multiple templates in a class
```
#ifndef __PAIR_H__
#define __PAIR_H__

template <class T1, class T2>
class Pair
{
    private:
        T1 first;
        T2 second;
    public:
        Pair(T1 first, T2 second);
};

template <class T1, class T2>
Pair<T1,T2>::Pair(T1 first, T2 second)
{
    this->first = first;
    this->second = second;
}

#endif __PAIR_H__

#include <iostream>
#include "Point.h"
#include "Pair.h"

typedef Point<int> pointI;
typedef Point<float> pointF;
typedef Point<double> pointD;

int main() {

    pointI p1(2,5);
    pointF p2(3.5,8.5);
    pointD p3(0.002, 0.003);

    Point<int> * p4 = new Point<int>(4,5);

    p1.print();
    p2.print();
    p3.print();
    p4->print();

    Pair<int,int> pair1(1,2);
    Pair<int,float> pair1(1,2);
    Pair<int,double> pair1(1,2);

    return 0;
}
```

And we can combine templates!
```
 Pair<Point<int>, Point<float>> line(p1, p2);
```

Standard Template Library

Consists of algorithms and data structures 
Provides general purpose classes and functions
Helps to store and manipulate objects and makes the program reusable and robust
Consists of:
Containers
Iterators
Algorithms
Function objects

Vector Demo

```
#include <iostream>
#include <vector>
using namespace std;

class Point
{
public:
    int x;
    int y;
};

int main()
{
    vector<Point> v;

    Point p1 = {2,3};
    v.push_back(p1);
   
    for ( int i = 0; i < v.size(); i++)
    {
        cout << v[i].x << " " << v[i].y << endl;
    }

    return 0;
}
```

Maps
Is a way to store a key value pair
A map allows fast access to the value using the key
A map ensures that a key is unique across the entire data structure

```
#include <iostream>
#include <vector>
#include <map>
#include <string>

using namespace std;

class Point
{
public:
    int x;
    int y;
};

typedef map<string,int> StudentRecords;
typedef pair<string, int> Entry;

int main()
{
    StudentRecords t;
    Entry e = {"Sam",1799298};
   
    t.insert(e);

    int id = t["Sam"];

    cout << id << endl;

    return 0;
}
```

Iterators 
Are used to traverse through elements of containers
begin(): this function points the iterator to the first element of the container
end(): this function points the iterator to the last element of the container

```
int main()
{
    vector<int> v = {1,2,3,4,5,6,7,8};
    vector<int>::iterator itr;

    for (itr = v.begin(); itr < v.end() ; itr++)
    {
        cout << *itr << endl;
    }
   
    return 0;
}
```

Algorithms
Capable of performing certain actions to a data set. Search, find, sort, reverse, etc.

```
int main()
{
    vector<int> v = {1,2,3,4,5,6,7,8};
    vector<int>::iterator itr;

    sort(v.begin(), v.end());
    reverse(v.begin(), v.end());

    vector<int>::iterator a = find(v.begin(), v.end(),8);
    cout << *a << endl;

    for (itr = v.begin(); itr < v.end() ; itr++)
    {
        cout << *itr << endl;
    }
   
    return 0;
}
```

Function Objects
Also called functor
Any type that implements operator()
The operated is referred to as the call operator
Confusing as fuck

```
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <cmath>

using namespace std;

class Point
{
    public:
        int x;
        int y;
        float operator() (Point p2)
        {
            return sqrt(pow(x-p2.x,2) + pow(x-p2.y,2));
        }
    private:
};

int main()
{
    Point p1 = {10,50};
    Point p2 = {0,5};

    float dist = p1(p2);

    cout << dist << endl;
   
    return 0;
}
```

---

I apologize for any misunderstanding, and I hope this is helpful. Please let me know if you have any further questions or need additional assistance.