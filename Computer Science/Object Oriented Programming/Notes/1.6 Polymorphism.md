## Overloading
Separate functions share the same name with different signatures.

## Overriding
One function in the child replaces another with the same name and signature in the parent.

```cpp
#include <iostream>
#include <string>
using namespace std;

class A {
    protected:
        int _s;
    public:
        A(int s): _s(s) {}
        A(): A(-1) {}

        void add(int j) {
            _s += j;
        }
        // overloading the add function by changing the parameter type
        void add(double j) {
            _s += static_cast<int>(j);
        }
        void print() {
            cout << "S = " << this->_s << endl;
        }
};

class B : public A {
    private:
        double _k;

    public:
        B(int s, double k): A(s), _k(k) {}
        B(): B(0, 0) {}

        // overriding the function
        void print() {
            cout << "S = " << this->_s << " K = " << this->_k << endl;
        }
};
```

## Polymorphism
The same entity behaves differently in different scenarios.  
Builds upon inheritance.  
Implemented using virtual functions.

## Static Binding
The compiler matches a function call with the correct functions definition at compile time.

## Late Binding
Tells the compiler to wait until the function is used in the program.  
Decide which definition to use based on calling object.  
Declare a function with the keyword `virtual` if you want the compiler to use dynamic binding for that specific function.

```cpp
class A {
    protected:
        int _s;
    public:
        A(int s): _s(s){}
        A():A(-1) {}
        // runtime polymorphism
        virtual void print() {
            cout << "S = " << this->_s << endl;
        }
};

class B : public A {
    private:
        double _k;
   
    public:
        B(int s,double k):A(s), _k(k) {}
        B():B(0,0) {}
        // overriding the function
        void print() {
            cout << "S = " << this->_s << " K = "<< this->_k << endl;
        }
};

void test(A* a) {
    a->print();
}

int main() {
    A a1(564);
    B b1(500, 0.123);
    test(&a1);
    test(&b1);

    return 0; 
}
```

### Example Compilation Outputs

- With `virtual` keyword:
```
g++ main.cpp -o main.out
./main.out
S = 564
S = 500 K = 0.123 // switches to overridden print function from derived class
```

- Without `virtual` keyword:
```
g++ main.cpp -o main.out
./main.out
S = 564
S = 500 // still uses the original parent print function
```

## Virtual Functions
- Define a virtual function in the base class. The word `virtual` appears ONLY in the base class.
- If a base class declares a virtual function, it must implement that function, even if the body is empty.
- Virtual functions stay virtual in ALL the derived classes.
- A derived class is not required to override a virtual function. If it does not, the base class version is used.

## Disadvantages of Virtual Functions
- Overhead: uses more storage as the compiler needs to build a virtual function table.
- Has pointers for each virtual member function.
- Points to location of correct code for that function.
- Late binding is on the fly so programs run slower.

## Default Copy Constructor
In addition to the no-arguments default constructor:
- Initializes an object with another object of the same type.
- Built into all classes.
- One argument constructor whose argument is an object of the same class as the constructor.
- Used when we pass and return objects to functions.

// ... [Your remaining code snippets and notes]

```

Please note that the conversion assumes you will place this Markdown content in a Markdown file, and then the file will be processed (e.g., rendered in a Markdown viewer, converted to HTML by a static site generator, etc.) to produce the desired formatted output.****