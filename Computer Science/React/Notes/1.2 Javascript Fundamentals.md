## Destructuring Objects

- We can easily grab contents of an object without needing to set a variable to be equal to another value
- Instead of:

```js
const var = obj.var;
```

- We can write:

```js
const { var } = obj;
```

- Provided that the variable exists within the object already (otherwise it will be set to null)


## Destructuring Arrays

- Usually we would grab an element from an array using `[]`

```js
const primary = obj[0];
const secondary = obj[1];
```

- We can do this more efficiently using destructuring

```js
const [primary, secondary] = obj;
```

- The order in which variables are set is the order of which value at index x is assigned to it ( starting from 0)

## Rest Operator

- After destructuring elements from an array, the rest operator can be used to place the remaining elements inside another array

```js
const [primary, secondary ...others] = obj;
```

## Spread Operator

- Used to destructure an array so that it can be combined with new elements inside a new array
	- Essentially used to append a new element to an array
- Can append OR prepend new element

```js
const updatedArray = [...arr, 'newElement'];
```

- Can also be used to add new variables to an object

```js
const updatedObject = { ...obj, newVariable: 'newThing' };
```

- We can also use the spread operator to update existing variables inside the array by changing the value associated with a variable that already exists

```js
const updatedObject = { ...obj, newVariable: 'newThing', updatedVariable: 'updatedValue' };
```

## Template Literals
- Used to combine variables with strings, using backticks \`\`
- Place string inside backticks and use `${}` to append the value of a variable within a string
	- This value can be any sort of JavaScript that returns a value ( this means you can destructure arrays, objects, etc to get values, even call functions)

```js
const title = 'The Lord of the Rings';
const author = "J.R.R Tolkien";
const date = 1991;

const combinedString = `${title} was written by ${author} in ${date}`;

console.log(combinedString);
```

## Ternary Operators
- Instead of writing verbose if else statements,  we can write a single line of code to initialise, set and condition a variable
- The `?` means if the  statement is true, then do the right of me
- The `:` means if the statement was not true, then do the right of me

```js
pages=999;

const pagesRange = pages > 1000 ? "over a thousand" : "less than a thousand";

console.log(pagesRange)
```

- We can combine ternary operators and template literals to conditionally render a string

```js
const title = 'The Lord of the Rings';
const author = "J.R.R Tolkien";
const date = 1991;
const hasMovie=true;

const combinedString = `
${title} was written by ${author} in ${date}. 
The book has ${hasMovie ? "" : "Not"}been adapted as a movie.`;

console.log(combinedString);
```

- We *can* do this with if / else statements but it would be much more verbose

```js
const title = 'The Lord of the Rings';
const author = "J.R.R Tolkien";
const date = 1991;
const hasMovie = true;

let movieStatus;

if (hasMovie) {
    movieStatus = "";
} else {
    movieStatus = "Not";
}

const combinedString = `
${title} was written by ${author} in ${date}. 
The book has ${movieStatus}been adapted as a movie.`;

console.log(combinedString);
```

## Arrow Functions
- A shorter way to write functions (and store them as function expressions)
- We point a variable at some sort of logic using `=>`
	- The expression can then be stored as a function

```js
const getYear = (str) => str.split("-")[0];
```

- Can write multi line functions, which require a return statement

```js
const getYear = (str) => {
	return str.split("-")[0];
}
```

## Short Circuiting and Logical Operators
- In certain logical operations, the operator will return the first value and not bother with the second value
- We can use true / false or truthy / falsy values instead
	- Falsy values are `0, '', null, undefined`
	- Truthy values are everything else
- Essentially, we can use this as an even less verbose if else statement

### && 
- If the first variable is false, then we don't look at the second value and short circuit
- If the first variable is true, then we do

```js
const isTrue=true;
console.log(isTrue && "This is true");

const emptyVar=0;
console.log(emptyVar && "This is a short circuit")
```

### ||
- OR logical operators are the opposite
	- If the first value is true, then we short circuit
	- If the first value is false, then we look at the second value

```js
const isTrue=true;
console.log(isTrue || "This is true");

const emptyStr=''
console.log(emptyStr || "This is a short circuit")
```

- Short circuits are really useful for checking if your desired variable exists and if it doesn't - setting a default value

```js
function getUserData() {
    return {
        username: null,
        email: 'user@example.com'
    };
}

const data = getUserData();
const username = data.username || 'DefaultUser';

console.log(username); // Output: DefaultUser
```

### ??
- Can also use this operator to set the short circuit only when the left hand is null or undefined

```js
let width = 0;
let height = undefined;

console.log(width ?? 'short circuit');  // Output: 0
console.log(height ?? 'short circuit'); // Output: short circuit
```

## Optional Chaining
- Allows us to ignore calls on undefined objects
- Say we want to add two variables from an object
	- Optional chaining allows us to ignore one of the variables if they don't exist (allowing us to use the singular other value)

```js
let data = {
    settings: {
        valueA: 10,
    }
};

// Using optional chaining
let sum = (data?.settings?.valueA ?? 0) + (data?.settings?.valueB ?? 0);

console.log(sum); // Output: 10
```

- Without chaining, this would result in an error because valueB is undefined

## Array Methods

### Map
- Iterates over an array and performs a supplied function on each element in that array, returning the modified array

```js
[1,2,3,4,5].map
```