![[figure_II.3.png]]

- The ultimate goal is to be able to write high level code in Jack, use a compiler to compile it into bytecode, which is then translated into assembly code and then finally assembled into machine code, to be executed by the hardware.
- This two tier compilation model allows for cross platform compatibility, because we run the bytecode on a virtual machine which can then be translated according to the machine it's running on

## The Virtual Machine Paradigm
- High level code must be translated into machine code before it can run
	- We break this down into two stages
	1. High level code is parsed and translated into intermediate steps
	2. The intermediate steps are translated further into low level machine code of the target hardware
	- This allows us to keep a single high level compiler for a language, and implement virtual machines for different hardware sets to translate intermediate code
- This first program, called the compiler, translates high level code into intermediate VM commands
- The second program, called the VM translator, translates the VM commands further into the machine instructions of the target hardware platform 

![[figure_7.1.png]]

- The benefit with this model, is it allows developers to write code once, and execute it anywhere, even on new devices that don't exist yet
- The cost with this is reduced efficiency - verbose machine code as a result of multiple compilations

## Stack Machine
- Effective VM languages strike a balance between high and low level syntax
	- Should have reasonable expressive power - arithmetic logical commands, push / pop commands, function commands