## Background
- Machine languages can be binary or symbolic
- Writing binary machine code is borderline impossible (or at least wildly inefficient)
- This is why we write machine code symbolically and use an assembler to convert it to binary
	- And later, a compiler to convert high level languages into assembly code

![[figure_6.1.png]]

## Translating Assembly to Binary 
- Input a stream of assembly instructions and generate an output of binary instructions
- Output is loaded into computer memory and executed
- Assembler must handle instructions and symbols

### Handling Instructions
1. Parse instruction into fields
2. For each field, generate corresponding bit code
3. If instruction contains a symbolic reference, convert symbol into it's numeric value
4. Assemble resulting binary into strings of sixteen bits (1 word)
5. Write assembled string to output file

### Handling Symbols
- Needs to read code twice, from start to end to handle jumps
	- In first read, assembler builds a *symbol* table which contains all the symbols in the code
	- In second read, assembler handles variable symbols and generates binary code using the symbol table

#### Initialisation
- Creates the symbol table and fills it with predefined symbols and their pre allocated values (recall, we have predefined symbols up to register 15, so variable symbols start from 16 onwards)
	- Up to and including `KBD`

#### First Read
- Reads line by line, keeping track of line number (starting at 0) and increments +1 whenever an A or C instruction is read (not for comments or label declarations)
- Each time a le



