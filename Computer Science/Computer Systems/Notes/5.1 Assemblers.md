## Background
- Machine languages can be binary or symbolic
- Writing binary machine code is borderline impossible (or at least wildly inefficient)
- This is why we write machine code symbolically and use an assembler to convert it to binary
	- And later, a compiler to convert high level languages into assembly code
- The challenge with doing this:
	- Extract the programs semantics (what it does) from the source program, using the syntax (how it does it) of the source language
	- Re express the program's semantics in the target language, using the syntax of the target language

![[figure_6.1.png]]
## Translating Assembly to Binary 
- Input a stream of assembly instructions and generate an output of binary instructions
- Output is loaded into computer memory and executed
- Assembler must handle instructions and symbols


### Handling Instructions
1. Parse instruction into fields
2. For each field, generate corresponding bit code
3. If instruction contains a symbolic reference, convert symbol into it's numeric value
4. Assemble resulting binary into strings of sixteen bits (1 word)
5. Write assembled string to output file

### Handling Symbols
- Needs to read code twice, from start to end to handle jumps
	- In first read, assembler builds a *symbol* table which contains all the symbols in the code
	- In second read, assembler handles variable symbols and generates binary code using the symbol table

#### Predefined Symbols
- Are initialised before the assembler starts and have no special significance on their own
- Include:
	- Virtual Registers
		- `R0...R15` 
		- Are automatically predefined to RAM addresses `0..15`
	- I/O pointers
	- 

#### Initialisation
- Creates the symbol table and fills it with predefined symbols and their pre allocated values
	- Up to and including `KBD`

#### First Read
- Reads line by line, keeping track of line number (starting at 0) and increments +1 whenever an A or C instruction is read (not for comments or label declarations `LOOP, END, etc`)
- Each time a label declaration is encountered, the assembler adds a new entry to the symbol table associating it with the current number line + 1 

#### Second Read
- Reads line by line again
	- For every A instruction with a symbolic reference is encountered `@xxx`, where `xxx` is a symbol and not a number, the assembler looks up `xxx` in the symbol table and replaces it with it's numeric value if found
	- If it's not found, it represents a new variable which is then stored in the symbol table with: 
	- `<xxx, value>`, where value is the next available address in the RAM (recall, we have predefined symbols up to register 15, so variable symbols start from 16 onwards `R0 ... R15`)
		- There are also IO pointers for `SCREEN` and `KBD` at address `16384` and `24576` respectively


## Implementation
- Call `HackAssembler` with `<progname>.asm` in the terminal, to output `progname.hack` with binary code

### Basic Assembler
- Assumes source code has no symbolic references
- Translates A and C instructions of form `@xxx`, where `xxx` can only be numbers
- For each grouped field `DEST=COMP;JMP` of each C instruction, translate into corresponding bit code
- For each `@xxx` code, translate into 16 bit address code
	- Recall, C instructions start with 1 and start with 0
- Achieved using 
	- Parse module to parse input into instructions and instructions into fields
	- Code module for translating fields into binary codes
	- Assembler program to drive everything

#### Parse Module
- Advances through source, skips comments / white space and breaks each symbolic instruction down into it's underlying components

![[figure_wo_caption_6.1.png]]

#### Code Module
- Translates each field created by the parsing module into a binary code

![[figure_wo_caption_6.2.png]]

- A instruction
	- Replace the symbolic reference (if any) with the corresponding number
	- If no symbolic reference, just convert the number to binary
- C instruction
	- For each field in the instruction, generate the corresponding binary code
#### Hack Assembler
- Drives previous two modules
- Basic version assumes no symbolic references
	- All instructions are of type `@xxx` where `x` are numbers only
	- Input file contains no label instructions
	1. Get name of file from command line arguments
	2. Constructs objects for modules
	3. Creates output file
	4. For each C instruction:
		1. Enter a loop that iterates through each line and process them:
			1. Use parse module to break instructions into fields
			2. Use code module to translate each field
		2. Concatenate translated binary intro a string of 16 binary chars and writes this string as the next line
	5. For each A instruction:
		1. Translate into binary representation consisting of 16 binary chars and writes this string as the next line

##### Example 

![[Pasted image 20230822103522.png]]

```
@7
- A instruction, therefore op code is 0
- translate 7 into 15 bit binary, which is 0000000...111
```

```
D=0
- C instruction, therefore op code is 1
- computation is =0, therefore a bit is 0 and comp field is 101010
- destination is D only, therefore dest field is 010
- no jump needed, so jump field is 0000
```

```
0;JMP
- C instruction, therefore op code is 1
- computation is =0, therefore a bit is 0 and comp field is 101010
- no storing anywhere, therefore dest field is 000
- performing unconditional jump, therefore jump field is 111
```

```
A=D&M;JLT
- C instruction, therefore op code is 1
- computation is D&M, therefore a bit is 1 and comp field is 000000
- storing in A, therefore dest field is 100
- performing less than jump, therefore jump field is 100
```

```
@BOB (assuming BOB=31)
- A instruction, therefore op code is 0
- Set remaining 15 bits to value of bob (which can be found using the symbol table) = 31
```

```
AD=!M
- C instruction, therefore op code is 1
- Computation is !M, therefore comp field is 110001
- Storing in AD, therefore dest field is 110
- No jump, so jump field is 000
```

![[Pasted image 20230815121257.png]]


#### Symbol Table
- Must resolve symbols into actual addresses using a table
- Achieved using a hash table `<key, value>` 

![[figure_wo_caption_6.3.png]]
