## Background
- Machine languages can be binary or symbolic
- Writing binary machine code is borderline impossible (or at least wildly inefficient)
- This is why we write machine code symbolically and use an assembler to convert it to binary
	- And later, a compiler to convert high level languages into assembly code

![[figure_6.1.png]]

## Translating Assembly to Binary 
- Input a stream of assembly instructions and generate an output of binary instructions
- Output is loaded into computer memory and executed
- Assembler must handle instructions and symbols

### Handling Instructions
1. Parse instruction into fields
2. For each field, generate corresponding bit code
3. If instruction contains a symbolic reference, convert symbol into it's numeric value
4. Assemble resulting binary into strings of sixteen bits (1 word)
5. Write assembled string to output file

### Handling Symbols
- Needs to read code twice, from start to end to handle jumps
	- In first read, assembler builds a *symbol* table which contains all the symbols in the code
	- In second read, assembler handles variable symbols and generates binary code using the symbol table

#### Initialisation
- Creates the symbol table and fills it with predefined symbols and their pre allocated values
	- Up to and including `KBD`

#### First Read
- Reads line by line, keeping track of line number (starting at 0) and increments +1 whenever an A or C instruction is read (not for comments or label declarations `LOOP, END, etc`)
- Each time a label declaration is encountered, the assembler adds a new entry to the symbol table associating it with the current number line + 1 (recall, we have predefined symbols up to register 15, so variable symbols start from 16 onwards)

#### Second Read
- Reads line by line again
	- For every A instruction with a symbolic reference is encountered `@xxx`, where `xxx` is a symbol and not a number, the assembler looks up `xxx` in the symbol table and replaces it with it's numeric value if found
	- If it's not found, it represents a new variable which is then stored in the symbol table with ``



