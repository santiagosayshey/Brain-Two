## Run Time System
- Controls:
	- How to start program execution
	- How to handle program termination
	- How to pass function arguments
	- How to allocate and free memory resources
- Realised via VM translator and its subsequent commands -`pop, push, add, etc`
	- Along with this, some sort of ‘wrapper’ that acts as a sort of ‘main’ function for everything to work together

## High Level Magic
- Allow writing programs in high level terms 

```
x=-b+sqrt(power(b,2)-4*a*c)
```

- Primitive operations like `+ and -` are built into the basic syntax, whereas `sqrt and power` are extensions of the language
- High level languages allow us to never have to worry about how things like this get executed and how we execute multiple things one after another
- Similarly, high level code abstracts away the ability to branch between logic - conditional execution
- The overhead of functions are also abstracted away. Behind the scenes, it needs to:
	- Save the return address (address in memory to return to once a function finishes executing)
	- Save memory resources of the caller
	- Allocate memory resources needed by the callee
	- Make arguments from caller memory available to callee
	- Execute the callee’s code
	- Make the callee’s return value available to caller’s code
	- Free the memory used by the callee
	- Reinstate the saved memory from the caller
	- Resume executing from the return address we initially saved
- The compiler or VM translator handles all of these things without the programmer ever having to worry about it

## Branching
- By default, programs execute sequentially (one instruction after the other)
- We can ‘redirect’ this execution, a for loop, via branching
	- Implemented using `goto` in assembly programming languages, followed by physical memory address of next instruction, or a symbolic label bound to an address
- VM language supports *conditional and unconditional* branching

### Unconditional Branching
- Using `goto`, we jump to execute the command just after the label symbol

### Conditional Branching
- Using `if-goto`, we pop the stack
	- If it’s true,  jump to the command after the label symbol
	- If it’s false, execute the next command in the code
- We need to specify this condition before the `if-goto` command

##### Examples
1. 
```
if (n<100) goto LOOP
```

becomes:

```
push n
push 100
lt
if-goto LOOP
```

2. Consider a function that receives two arts `x and y` and returns their product
- This can be achieved by adding x repetitively to a local variable `sum`, y times and then returning sum’s value

```c++
// Returns x*y
int mult(int x, int y) {
	int sum = 0;
	int i = 0;
	while (i < y) {
		sum += x;
		i++;
	}
	return sum;
}
```

- After being compiled into VM code, it becomes:

```
// Returns x*y
function mult(x,y)
	push 0
	push sum
	push 0
	pop i
label WHILE_LOOP
	push i
	push y
	lt
	neg
	if-goto WHILE_END
	push sum
	push x
	add
	pop sum
	push i
	push i
	add
	pop i
	goto WHILE_LOOP
label WHILE_END
	push sum
	return
```

- Notice that we negate the result of the condition. This essentially says that we have looped all times and have achieved the condition and can now skip to 'after' the while loop
- This means pretty much every high level conditional `if / while / etc` can be realised using only `goto / if-goto` commands

## Functions
- Programming languages have a set of fixed, built in operations
- In addition to this, they allow programmers to create their own operations (which are called functions)
- Built in and user defined operations have the same look and feel, i.e. we can use them interchangeably
	- In the context of our VM, a user defined function might be `multiply`, for which we call after pushing two values onto the stack, just as we would for a built in one like `add`
	- We call user defined functions using `call <function>`, where as built in ones are just `<function>`

##### Example - hypot

![](Images/Ch08_IEQ_002.png)

![](Images/figure_8.2.png)

- We can see that each function operates in their own stack universe, separate from the stack from it's parent uses
- Arguments and return variables magically (as we will soon see) travel through wormholes to get to new / existing stacks

### Implementation
- We have a `calling chain` which manages what function calls what, usually starting with main
- Each function in the chain waits for the function in front of it to return it a variable
- The last in the chain is the currently executing function

```
main -> foo -> bar
```

- Functions have `local` and `argument` temporary variables, stored inside their own stack
	- When the function starts executing, the memory is allocated and then freed once finished