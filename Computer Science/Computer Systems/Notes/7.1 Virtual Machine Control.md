## Run Time System
- Controls:
	- How to start program execution
	- How to handle program termination
	- How to pass function arguments
	- How to allocate and free memory resources
- Realised via VM translator and its subsequent commands - `pop, push, add, etc`
	- Along with this, some sort of ‘wrapper’ that acts as a sort of ‘main’ function for everything to work together

## High Level Magic
- Allow writing programs in high level terms 

```
x=-b+sqrt(power(b,2)-4*a*c)
```

- Primitive operations like `+ and -` are built into the basic syntax, whereas `sqrt and power` are extensions of the language
- High level languages allow us to never have to worry about how things like this get executed and how we execute multiple things one after another
- Similarly, high level code abstracts away the ability to branch between logic - conditional execution
- The overhead of functions are also abstracted away. Behind the scenes, it needs to:
	- Save the return address (address in memory to return to once a function finishes executing)
	- Save memory resources of the caller
	- Allocate memory resources needed by the callee
	- Make arguments from caller memory available to callee
	- Execute the callee’s code
	- Make the callee’s return value available to caller’s code
	- Free the memory used by the callee
	- Reinstate the saved memory from the caller
	- Resume executing from the return address we initially saved
- The compiler or VM translator handles all of these things without the programmer ever having to worry about it

## Branching
- By default, programs execute sequentially (one instruction after the other)
- We can ‘redirect’ this execution, a for loop, via branching
	- Implemented using `goto` in assembly programming languages, followed by physical memory address of next instruction, or a symbolic label bound to an address
- VM language supports *conditional and unconditional* branching

### Unconditional Branching
- Using `goto`, we jump to execute the command just after the label symbol

### Conditional Branching
- Using `if-goto`, we pop the stack
	- If it’s true,  jump to the command after the label symbol
	- If it’s false, execute the next command in the code
- We need to specify this condition before the `if-goto` command

##### Examples
1. 
```
if (n<100) goto LOOP
```

becomes:

```
push n
push 100
lt
if-goto LOOP
```

2. Consider a function that receives two arts `x and y` and returns their product
- This can be achieved by adding x repetitively to a local variable `sum`, y times and then returning sum’s value

```c++
// Returns x*y
int mult(int x, int y) {
	int sum = 0;
	int i = 0;
	while (i < y) {
		sum += x;
		i++;
	}
	return sum;
}
```

- After being compiled into VM code, it becomes:

```
// Returns x*y
function mult(x,y)
	push 0
	push sum
	push 0
	pop i
label WHILE_LOOP
	push i
	push y
	lt
	neg
	if-goto WHILE_END
	push sum
	push x
	add
	pop sum
	push i
	push i
	add
	pop i
	goto WHILE_LOOP
label WHILE_END
	push sum
	return
```

- Notice that we negate the result of the condition. This essentially says that we have looped all times and have achieved the condition and can now skip to 'after' the while loop
- This means pretty much every high level conditional `if / while / for / etc` can be realised using only `goto / if-goto` commands

## Functions
- Programming languages have a set of fixed, built in operations
- In addition to this, they allow programmers to create their own operations (which are called functions)
- Both built-in and user-defined operations can be utilized in a similar manner, giving them a consistent feel in their application.
	- In the context of our VM, a user defined function might be `multiply`, for which we call after pushing two values onto the stack, just as we would for a built in one like `add`
	- We call user defined functions using `call <function>`, where as built in ones are just `<function>`

##### Example - hypot

![](Images/Ch08_IEQ_002.png)

![](Images/figure_8.2.png)

- We can see that each function operates in their own stack universe, separate from the stack from it's parent uses
- Arguments and return variables magically (as we will soon see) travel through wormholes to get to new / existing stacks

### Implementation
- We have a `calling chain` which manages what function calls what, usually starting with main
- Each function in the chain waits for the function in front of it to return it a variable
- The last in the chain is the currently executing function

```
main -> foo -> bar
```

- Functions have `local` and `argument` temporary variables, stored inside their own stack
	- When the function starts executing, the memory is allocated and then freed once finished
- It can be realised that this is just another stack. A stack of stacks, where the first function in, is the last function out

##### Example - foobar
- Assume the current function is `foo`:
	- `foo` has pushed some values onto its stack and modified entries in its memory segments. Each function call creates a new frame on the stack designated for its local and argument segments.
  
- When `foo` calls `bar`, it pauses its execution:
	- The current state (or frame) of `foo` remains on the stack, with `bar`'s frame positioned on top. 
	- Before `bar` terminates, it pushes a return value onto the stack. Upon handling the return command, the VM implementation transfers the return value to argument 0 and adjusts the `SP` (Stack Pointer) to point to the address immediately following this value. This action effectively liberates the global stack's area beneath the new `SP` value. Consequently, when the caller (`foo`) resumes its operations, it identifies the return value at the pinnacle of its working stack. This mechanism permits functions to return values to their callers, with the return value stored in argument 0. Once `bar` completes, its frame is discarded, revealing `foo`'s frame, enabling the continuation of `foo`'s execution.

  - Before `bar`'s execution begins, pointers like `LCL, ARG, THIS, THAT` are saved in the beginning of `bar`'s stack frame to preserve the state of `foo`.
  - Functions can be seen as reducing complex execution to a single value (the return value). Conceptually, calling a function is akin to pushing a value onto the caller's stack.

- The combined set of working stacks and frames is termed the `global stack`.


![](Images/figure_8.3.png)
