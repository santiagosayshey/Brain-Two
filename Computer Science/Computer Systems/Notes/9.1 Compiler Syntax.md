> A compiler is a program that translates programs from a source language *Jack* into a target language *Hack VM*

- We parse code syntax to understand it’s semantics and reveal intent

## Background
- Compilation consists of two stages:
	1. Syntax Analysis (divided into two more stages)
		1. Tokenising - grouping input characters into *atoms*
		2. Parsing - grouping tokens into structured statements that have meaning
		- Understands the structure of the program
	1. Code Generation

![[Pasted image 20231002234954.png]]

### Syntax Analysis
- Humans can interpret code syntax and notation literally, compilers can be taught to do the same through lexical analysis

#### Lexical Analysis
- Jack has a set of *tokens* or words that form the *lexicon*
	- Keywords - `class, while, for, etc`
	- Symbols - `+, <, etc`
	- Integer Constants - `17, 214, etc`
	- String Constants - `”FAQ”, “NAME”, etc`
	- Identifiers -  textual labels for naming variables, classes, functions
- These tokens are treated as the simplest elements in a program and are fed 1 by 1 into the compiler for code generation
- Essentially, LA turns a stream of characters into a stream of tokens

![[Pasted image 20231003002309.png]]

#### Grammar
- Combines tokens into logical sentences
- It’s a language that describes another language
- A set of rules, each consisting of a left and a right side
	- Left side specifies the rule’s name and is not part of the language itself
	- Right side describes the pattern of tokens that the rule specifies
		- This pattern goes from left to right and consists of `terminals, non terminals and qualifiers`
			- Terminals are tokens
			- Nonterminals are other rules
			- Qualifiers are represented by `|, *, ?, (, )`

![[Pasted image 20231003003608.png]]

- `|` means or
- `*` denotes something happens multiple times
- `?` means 0 or 1 times

#### Parsing
- Grammar is recursive. Rules can contain more rules, the result of which affects the rule before it.
- This correspondence can be represented with a data structure called a *parse tree*

![](Images/Pasted%20image%2020231003014724.png)

- Parse output (this tree) is denoted in XML, kinda like HTML markup

![](Images/Pasted%20image%2020231003014855.png)

#### Parser
- Accepts a stream of tokens as input and outputs a parse tree (XML)
- Algorithms used to create parse trees - *recursive descent parsing*
	- For each rule, there exists routines to compile those tokens into a parse tree
- Each `compilexxx` routine should get from the input, and handle, all the tokens that make up xxx, advance the tokenizer exactly beyond these tokens, and output the parse tree of xxx.

##### Example - Parsing `while`

- `while ( expression ) { statement* )`

![](Images/Pasted%20image%2020231003015251.png)



## Jack Specification

### Grammar

![](Images/Pasted%20image%2020231003140108.png)

![](Images/figure_10.5.png)
